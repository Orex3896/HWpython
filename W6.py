# Задача №39. Решение в группах
# Даны два массива чисел. Требуется вывести те элементы
# первого массива (в том порядке, в каком они идут в первом
# массиве), которых нет во втором массиве. Пользователь вводит
# число N - количество элементов в первом массиве, затем N
# чисел - элементы массива. Затем число M - количество
# элементов во втором массиве. Затем элементы второго массива


# from random import randint
# N = int(input("Введите кол-во элементов массива А = "))
# M = int(input("Введите кол-во элементов массива B = "))
# array_A=[randint(1,10) for i in range(N)]
# array_B=[randint(1,10) for i in range(M)]
# print("Array_A")
# print(array_A)
# print("Array_B")
# print(array_B)
# print([x for x in  array_A if x not in (array_B)])
# array_C=set(array_A(array_B))
# print("Array_C")
# print(array_C)

# Задача №41. Общее обсуждение
# Дан массив, состоящий из целых чисел. Напишите
# программу, которая в данном массиве определит
# количество элементов, у которых два соседних и, при
# этом, оба соседних элемента меньше данного. Сначала
# вводится число N — количество элементов в массиве
# Далее записаны N чисел — элементы массива. Массив
# состоит из целых чисел.

# count = 0
# array_A=[1,5,1,3,4,5]
# print(array_A)

# for i in range(1,len(array_A)-1):
#     if(array_A[i]>array_A[i-1] & array_A[i]>array_A[i+1]):
#         count+=1
# print(count)

#2 Способ

# count = 0
# array_A=[1,5,1,3,2,5]#Два числа здесь будет
# print(array_A)

# #for i in range(1,len(array_A)-1):
# #    if(array_A[i] == max(array_A[i-1:i+2])):#здесь использовали срез!!! это двоеточие
#         # ищем максимальное между i-1,потом наш i и i+2( так как у нас идёт до i+1)
# # count+=1
# # print(count)

# #3способ
# #методом comperhansion у нас подсчёт сразу идёт через len         
# print(len([i for i in range(1,len(array_A)-1) if array_A[i] == max(array_A[i-1:i+2])]))

# Задача №43. Решение в группах
# Дан список чисел. Посчитайте, сколько в нем пар
# элементов, равных друг другу. Считается, что любые
# два элемента, равные друг другу образуют одну пару,
# которую необходимо посчитать. Вводится список
# чисел. Все числа списка находятся на разных
# строках.
# Ввод:       Вывод:
# 1 2 3 2 3   2


# list_1 = [1,2,3,1,2,3,4,5,3,2,3,3,1]
# # list_2 = list(set(list_1))
# # res = 0
# # for i in range(len(list_2)):
# #     res+=list_1.count(list_2[i])//2
# # print("Кол-во повторений = "+res)

# # 2 способ через словарик

# dict_list = {}.fromkeys(list_1,0)
# print(dict_list)
# for i in list_1:
#     dict_list[i]+=1
# print(sum([i//2 for i in dict_list.values() if not i%2]))


# Задача №45. Общее обсуждение
# Два различных натуральных числа n и m называются
# дружественными, если сумма делителей числа n
# (включая 1, но исключая само n) равна числу m и
# наоборот. Например, 220 и 284 – дружественные числа.
# По данному числу k выведите все пары дружественных
# чисел, каждое из которых не превосходит k. Программа
# получает на вход одно натуральное число k, не
# превосходящее 105
# . Программа должна вывести все
# пары дружественных чисел, каждое из которых не
# превосходит k. Пары необходимо выводить по одной в
# строке, разделяя пробелами. Каждая пара должна быть
# выведена только один раз (перестановка чисел новую
# пару не дает).

from time import time
from random import choices

li = []
user_in = (int(input("Input a number: ")))

start = time()
def sum_dev(num):
    cou = 1
    for i in range(2, int(num ** 0.5)):
        if num % i == 0:
            cou += i + num / i
    return cou

for j in range(10, user_in):
    first = sum_dev(j)
    second = sum_dev(first)
    if second == j and first < second:
        print(j, first)

print(time() - start) 